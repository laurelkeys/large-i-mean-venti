"""
Simulate a quadrotor following a 3D trajectory

Author: Daniel Ingram (daniel-s-ingram)
"""

from math import cos, sin
import numpy as np
from Quadrotor import Quadrotor
from TrajectoryGenerator import TrajectoryGenerator
from mpl_toolkits.mplot3d import Axes3D

show_animation = True

# Simulation parameters
g = 9.81 # gravity
m = 0.2  # mass
T = 5    # duration time
Ixx = Iyy = Izz = 1

# Proportional coefficients
Kp_x    = Kp_y     = Kp_z   = 1
Kp_roll = Kp_pitch = Kp_yaw = 25

# Derivative coefficients
Kd_x = 10; Kd_y = 10; Kd_z = 1

def quad_sim(x_c, y_c, z_c):
    """
    Calculates the necessary thrust and torques for the quadrotor to
    follow the trajectory described by the sets of coefficients
    x_c, y_c, and z_c.
    """
    x_pos = -5; y_pos = -5; z_pos = 5

    x_vel    =  y_vel     = z_vel   = 0
    x_acc    =  y_acc     = z_acc   = 0
    roll     =  pitch     = yaw     = 0
    roll_vel =  pitch_vel = yaw_vel = 0

    des_yaw = 0

    dt = 0.1
    t = 0

    q = Quadrotor(x=x_pos, y=y_pos, z=z_pos, 
                  roll=roll, pitch=pitch, yaw=yaw, 
                  size=1, show_animation=show_animation)

    i = 0
    n_run = 8
    irun = 0
    try:
        while True:
            while t <= T:
                # des_x_pos = calculate(x_c[i], t, value='position')
                # des_y_pos = calculate(y_c[i], t, value='position')
                des_z_pos = calculate(z_c[i], t, value='position')

                # des_x_vel = calculate(x_c[i], t, value='velocity')
                # des_y_vel = calculate(y_c[i], t, value='velocity')
                des_z_vel = calculate(z_c[i], t, value='velocity')

                des_x_acc = calculate(x_c[i], t, value='acceleration')
                des_y_acc = calculate(y_c[i], t, value='acceleration')
                des_z_acc = calculate(z_c[i], t, value='acceleration')

                thrust = m * (g + des_z_acc + Kp_z * (des_z_pos - z_pos) + Kd_z * (des_z_vel - z_vel))

                roll_torque  = Kp_roll  * (((des_x_acc * sin(des_yaw) - des_y_acc * cos(des_yaw)) / g) - roll)
                pitch_torque = Kp_pitch * (((des_x_acc * cos(des_yaw) - des_y_acc * sin(des_yaw)) / g) - pitch)
                yaw_torque   = Kp_yaw   * (des_yaw - yaw)

                roll_vel  += roll_torque  * dt / Ixx
                pitch_vel += pitch_torque * dt / Iyy
                yaw_vel   += yaw_torque   * dt / Izz

                roll  += roll_vel  * dt
                pitch += pitch_vel * dt
                yaw   += yaw_vel   * dt

                R = rotation_matrix(roll, pitch, yaw)
                acc = (np.matmul(R, np.array([0, 0, thrust])) - np.array([0, 0, m * g])) / m
                x_acc, y_acc, z_acc, *_ = acc
                x_vel += x_acc * dt; y_vel += y_acc * dt; z_vel += z_acc * dt
                x_pos += x_vel * dt; y_pos += y_vel * dt; z_pos += z_vel * dt

                q.update_pose(x_pos, y_pos, z_pos, roll, pitch, yaw)

                t += dt

            t = 0
            i = (i + 1) % 4
            irun += 1
            if irun >= n_run:
                break
    except KeyboardInterrupt:
        pass

    print("Done")

def calculate(c, t, value):
    """
    Calculates the position/velocity/acceleration value given a set of quintic coefficients and a time.

    Args
        c: List of coefficients generated by a quintic polynomial 
            trajectory generator.
        t: Time at which to calculate the value
        t: The value to be calculated: 'position', 'velocity' or 'acceleration'

    Returns
        Acceleration
    """
    coefficients = {
        'position':     [c[0],   c[1],    c[2],    c[3],   c[4],   c[5]],
        'velocity':     [   0, 5*c[0],  4*c[1],  3*c[2], 2*c[3],   c[4]],
        'acceleration': [   0,      0, 20*c[0], 12*c[1], 6*c[2], 2*c[3]]
    }
    C = coefficients[value]
    return C[0] * t**5 + C[1] * t**4 + C[2] * t**3 + C[3] * t**2 + C[4] * t + C[5]

def rotation_matrix(roll, pitch, yaw):
    """
    Calculates the ZYX rotation matrix.

    Args
        Roll: Angular position about the x-axis in radians.
        Pitch: Angular position about the y-axis in radians.
        Yaw: Angular position about the z-axis in radians.

    Returns
        3x3 rotation matrix as NumPy array
    """
    return np.array([[ cos(yaw) * cos(pitch),
                      -sin(yaw) * cos(roll) + cos(yaw) * sin(pitch) * sin(roll),
                       sin(yaw) * sin(roll) + cos(yaw) * sin(pitch) * cos(roll)],
                     [ sin(yaw) * cos(pitch),
                       cos(yaw) * cos(roll) + sin(yaw) * sin(pitch) * sin(roll),
                      -cos(yaw) * sin(roll) + sin(yaw) * sin(pitch) * cos(roll)],
                     [-sin(pitch), 
                       cos(pitch) * sin(roll), 
                       cos(pitch) * cos(yaw)]])


def main():
    """
    Calculates the x, y, z coefficients for the four segments 
    of the trajectory
    """
    x_coeffs  = np.zeros(shape=(4, 6))
    y_coeffs  = np.zeros(shape=(4, 6))
    z_coeffs  = np.zeros(shape=(4, 6))
    waypoints = [[-5, -5, 5], [5, -5, 5], [5, 5, 5], [-5, 5, 5]]

    for i in range(4):
        traj = TrajectoryGenerator(waypoints[i], waypoints[(i + 1) % 4], T)
        traj.solve()
        x_coeffs[i] = traj.x_c.ravel()
        y_coeffs[i] = traj.y_c.ravel()
        z_coeffs[i] = traj.z_c.ravel()

    quad_sim(x_coeffs, y_coeffs, z_coeffs)


if __name__ == "__main__":
    main()